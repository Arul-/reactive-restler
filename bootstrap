#!/opt/bin/php
<?php

use Lambda\Convert;
use LogicalSteps\Async\Async;
use Luracast\Restler\Defaults;
use Luracast\Restler\Restler;
use Luracast\Restler\Utils\ClassName;
use Luracast\Restler\Utils\Dump;
use Psr\Http\Message\ServerRequestInterface;
use React\Promise\Promise;
use React\Promise\PromiseInterface;
use Swoole\Coroutine\Http\Client;

//set_time_limit(0);
//ignore_user_abort(true);
ini_set('display_errors', 1);
ini_set('display_startup_errors', 1);
error_reporting(E_ALL);

require __DIR__ . '/api/bootstrap.php';

Defaults::$cacheDirectory = '/tmp/store';

function url(string $path = ''): string
{
    return sprintf("http://%s/%s", $_ENV['AWS_LAMBDA_RUNTIME_API'] ?? '127.0.0.1:9001', ltrim($path, '/'));
}

function fetch(string $url, string $method = 'GET', array $headers = [], string $body = ''): array
{
    $headerText = '';
    foreach ($headers as $key => $value)
        $headerText .= "$key: $value\r\n";
    $context = stream_context_create([
        "http" => [
            "method" => $method,
            "header" => $headerText,
            "content" => $body,
            "ignore_errors" => true,
        ]]);

    $response = @file_get_contents($url, false, $context);
    if (!isset($http_response_header))
        return [-1, '', []];

    $responseHeaderLines = $http_response_header;
    $status_line = array_shift($responseHeaderLines);
    preg_match('{HTTP\/\S*\s(\d{3})}', $status_line, $match);
    $status = $match[1];

    $responseHeaders = [];
    foreach ($responseHeaderLines as $value) {
        $value = explode(': ', $value, 2);
        $responseHeaders[$value[0]] = $value[1];
    }
    return [$status, $response, $responseHeaders];
}

function lambda_request()
{
    [$statusCode, $requestBody, $headers] = fetch(url('/2018-06-01/runtime/invocation/next'));
    $requestBody = json_decode($requestBody, true) ?? [];
    $invocationId = $headers['lambda-runtime-aws-request-id'] ?? 'id';
    return compact('invocationId', 'headers', 'statusCode', 'requestBody');
}

function lambda_response(string $invocationId, string $body)
{
    [$statusCode, $requestBody, $headers] = fetch(
        url("/2018-06-01/runtime/invocation/{$invocationId}/response"),
        'POST',
        [],
        $body
    );
    return $statusCode;
}

function wait(PromiseInterface $promise)
{
    $result = null;
    $exception = null;
    $isRejected = false;

    $wait = true;
    while ($wait) {
        $promise
            ->then(function ($r) use (&$result) {
                $result = $r;
            }, function ($e) use (&$exception, &$isRejected) {
                $exception = $e;
                $isRejected = true;
            })
            ->always(function () use (&$wait) {
                $wait = false;
            });
    }

    if ($isRejected) {
        if (!$exception instanceof \Exception) {
            $exception = new \UnexpectedValueException(
                'Promise rejected with unexpected value of type ' . (is_object($exception) ? get_class($exception) : gettype($exception))
            );
        }

        throw $exception;
    }

    return $result;
}


function loop()
{
    do {
        $data = lambda_request();
        if ('id' === $data['invocationId']) continue;
        //echo 'request: ' . json_encode($data, JSON_PRETTY_PRINT) . PHP_EOL;
        $psrRequest = Convert::toPSR7($data['requestBody'], $data['headers']);
        echo Dump::request($psrRequest);
        $r = new Restler;
        $psrResponse = wait($r->handle($psrRequest));
        echo 'BASE: ' . $r->baseUrl . PHP_EOL;
        echo Dump::response($psrResponse) . PHP_EOL . PHP_EOL;
        //echo json_encode(Convert::fromPSR7($psrResponse), JSON_PRETTY_PRINT) . PHP_EOL;
        echo '-----------------------------------------' . PHP_EOL;
        lambda_response($data['invocationId'], json_encode(Convert::fromPSR7($psrResponse)));

    } while (true);
}

loop();
